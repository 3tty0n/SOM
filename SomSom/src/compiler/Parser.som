Parser = (
  | lexer sym text nextSym filename cgenc universe |

  initializeWith: aString for: aFilename in: aUniverse = (
    filename := aFilename.
    lexer := Lexer new: aString.
    universe := aUniverse.
    cgenc := ClassGenerationContext new: universe.
    self takeSymbolFromLexer.
  )

  takeSymbolFromLexer = (
    sym := lexer sym.
    text := lexer text.
    nextSym := #none.
  )

  classdef = (
    | name |
    name := universe symbolFor: text.
    self expect: #identifier.
    self expect: #equal.

    self superclass.

    self expect: #newTerm.
    self classBody.

    (self accept: #separator) ifTrue: [
      cgenc startClassSide.
      self classBody ].

    self expect: #endTerm.
    ^ cgenc
  )

  classBody = (
    self fields.
    [self symIsMethod] whileTrue: [
       | mgenc |
       mgenc := MethodGenerationContext new: cgenc.
       mgenc addArgument: 'self'.
       self method: mgenc.
       cgenc addMethod: (mgenc assemble: universe) ].
  )

  superclass = (
    | superName |
    sym == #identifier
      ifTrue: [
        superName := universe symbolFor: text.
        self accept: #identifier ]
      ifFalse: [
        superName := universe symbolFor: 'Object' ].

    cgenc superName: superName.

    superName string = 'nil' ifFalse: [
      self initializeFromSuperClass: superName ].
  )

  initializeFromSuperClass: superName = (
    'TODO once parser complete' println.
    "TODO
    | superClass |
    superClass := universe loadClass: superName.
    superClass == nil ifTrue: [
      self error: 'Was not able to load super class: ' + superName ].
    cgenc instanceFieldsOfSuper: superClass instanceFields.
    cgenc classFieldsOfSuper: superClass somClass instanceFields."
  )

  fields = (
    (self accept: #or) ifTrue: [
      [sym == #identifier] whileTrue: [
        | var |
        var := self variable.
        cgenc addField: (universe symbolFor: var) ].
      self expect: #or ]
  )

  method: mgenc = (
    self pattern: mgenc.
    self expect: #equal.

    sym == #primitive
      ifTrue: [
        mgenc markAsPrimitive.
        self primBlock ]
      ifFalse: [
        self methodBlock: mgenc ]
  )

  primBlock = (
    self expect: #primitive
  )

  pattern: mgenc = (
    sym == #identifier ifTrue: [
      ^ self unaryPattern: mgenc ].
    sym == #keyword ifTrue: [
      ^ self keywordPattern: mgenc ].
    self binaryPattern: mgenc
  )

  unaryPattern: mgenc = (
    mgenc signature: self unarySelector
  )

  binaryPattern: mgenc = (
    mgenc signature: self binarySelector.
    mgenc addArgumentIfAbsent: self argument
  )

  keywordPattern: mgenc = (
    | kw |
    kw := ''.

    [sym == #keyword] whileTrue: [
      kw := kw + self keyword.
      mgenc addArgumentIfAbsent: self argument ].

    mgenc signature: (universe symbolFor: kw)
  )

  methodBlock: mgenc = (
    self expect: #newTerm.

    self blockContents: mgenc.

    " if no return has been generated so far, we can be sure there was no . (dot)
      terminating the last expression, so the last expression's value must be
      popped off the stack and a ^self be generated "
    mgenc isFinished ifFalse: [
      'TODO implement bcGen' println.
      "TODO:
      bcGen.emitPOP(mgenc);
      bcGen.emitPUSHARGUMENT(mgenc, (byte) 0, (byte) 0);
      bcGen.emitRETURNLOCAL(mgenc);"
      mgenc markAsFinished ].

    self expect: #endTerm.
  )

  blockContents: mgenc = (
    (self accept: #or) ifTrue: [
      self locals: mgenc.
      self expect: #or ].
    self blockBody: mgenc sawPeriod: false
  )

  locals: mgenc = (
    [sym == #identifier] whileTrue: [
      mgenc addLocalIfAbsent: self variable ]
  )

  blockBody: mgenc sawPeriod: seenPeriod = (
    (self accept: #exit) ifTrue: [
      ^ self result: mgenc ].

    sym == #endBlock ifTrue: [
      seenPeriod ifTrue: [
        "a POP has been generated which must be elided (blocks always
         return the value of the last expression, regardless of
         whether it was terminated with a . or not)"
        mgenc removeLastBytecode ].
      bcGen emitReturnLocal: mgenc.
      mgenc markAsFinished.
      ^ self ].

    sym == #endTerm ifTrue: [
      "it does not matter whether a period has been seen, as the end of
       the method has been found (EndTerm) - so it is safe to emit a
       'return self'"
      'TODO implement bcGen' println.
      "TODO: bcGen.emitPUSHARGUMENT(mgenc, (byte) 0, (byte) 0);
      bcGen.emitRETURNLOCAL(mgenc);"
      mgenc markAsFinished.
      ^ self ].

    self expression: mgenc.
    (self accept: #period) ifTrue: [
      'TODO implement bcGen' println.
      "bcGen.emitPOP(mgenc);"
      self blockBody: mgenc sawPeriod: true ]
  )

  unarySelector = (
    ^ universe symbolFor: self identifier
  )

  binarySelector = (
    | s |
    s := text.

    (self accept: #or) or: [
    (self accept: #comma) or: [
    (self accept: #minus) or: [
    (self accept: #equal) or: [
    (self accept: #operatorSequence) or: [
    (self acceptOneOf: Parser singleOpSyms) or: [
        self expect: #none ] ] ] ] ] ].

    ^ universe symbolFor: s
  )

  variable = (
    ^ self identifier
  )

  argument = (
    ^ self variable
  )

  identifier = (
    | s |
    s := text.
    (self accept: #primitive)
      ifFalse: [self expect: #identifier].
    ^ s
  )

  keyword = (
    | s |
    s := text.
    self expect: #keyword.
    ^ s
  )

  expression: mgenc = (
    self peekForNextSymbolFromLexer.

    nextSym == #assign
      ifTrue: [self assignation: mgenc]
      ifFalse: [self evaluation: mgenc]
  )

  evaluation: mgenc = (
    | superSend |
    superSend := self primary: mgenc.
    self symInMethod ifTrue: [
      self messages: mgenc with: superSend ]
  )

  primary: mgenc = (
    | superSend |
    superSend := false.

    sym == #identifier ifTrue: [
      | v |
      v := self variable.
      v = 'super' ifTrue: [
        superSend := true.
        " sends to super, but pushes self as receiver"
        v := 'self' ].

      self gen: mgenc pushVariable: v.
      ^ superSend ].

    sym == #newTerm ifTrue: [
      self nestedTerm: mgenc.
      ^ superSend ].

    sym == #newBlock ifTrue: [
      | bgenc blockMethod |
      bgenc := MethodGenerationContext new: mgenc holder with: mgenc.
      bgenc markAsBlockMethod.

      self nestedBlock: bgenc.

      blockMethod := bgenc assembleMethod: universe.
      mgenc addLiteral: blockMethod.

      bcGen emit: mgenc pushBlock: blockMethod.
      ^ superSend ].

    self literal: mgenc.
    ^ superSend
  )

  literal: mgenc = (
    sym == #pound ifTrue: [
      self peekForNextSymbolFromLexerIfNecessary.
      nextSym == #newTerm
        ifTrue: [ self literalArray: mgenc ]
        ifFalse: [ self literalSymbol: mgenc ].
      ^ self ].

    sym == #string ifTrue: [
      self literalString: mgenc.
      ^ self ].

    self literalNumber: mgenc
  )

  literalArray: mgenc = (
    self error: 'literalArray nyi'
  )

  literalSymbol: mgenc = (
    self error: 'literalSymbol nyi'
  )

  literalString: mgenc = (
    self error: 'literalString nyi'
  )

  literalNumber: mgenc = (
    | lit |
    sym == #minus
      ifTrue: [lit := self negativeDecimal]
      ifFalse: [lit := self literalDecimal: false].

    mgenc addLiteralIfAbsent: lit.
    bcGen emit: mgenc pushConstant: lit
  )

  literalDecimal: isNegative = (
    sym == #integer
      ifTrue: [^ self literalInteger: isNegative]
      ifFalse: [^ self literalDouble: isNegative]
  )

  literalDouble: isNegative = (
    | d |
    d := Double fromString: text.
    isNegative ifTrue: [
      d := 0.0 - d ].

    self expect: #double.
    ^ universe newDouble: d
  )

  accept: s = (
    sym == s ifTrue: [
      self takeSymbolFromLexer.
      ^ true ].
    ^ false
  )

  acceptOneOf: ss = (
    (self symIn: ss) ifTrue: [
      self takeSymbolFromLexer.
      ^ true ].
    ^ false
  )

  expect: s = (
    (self accept: s) ifTrue: [ ^ true ].

    self error: 'Parsing failed, expected ' + s + ' but found ' + sym + ' (' + text + ')'
  )

  symIsMethod = (
    ^ sym = #identifier or: [
      sym = #keyword or: [
      sym = #operatorSequence or: [
      self symIn: Parser binaryOpSyms ] ] ]
  )

  symIn: ss = (
    ^ ss contains: sym
  )

  peekForNextSymbolFromLexer = (
    nextSym := lexer peek
  )

  ----
  | singleOpSyms binaryOpSyms keywordSelectorSyms |

  singleOpSyms = (
    singleOpSyms == nil ifTrue: [
      singleOpSyms := #(#not #and #or #star #div #mod #plus #equal
                        #more #less #comma #at #per #none) ].
    ^ singleOpSyms
  )

  binaryOpSyms = (
    binaryOpSyms == nil ifTrue: [
      binaryOpSyms := #(#or #comma #minus #equal #not #and #or #star
                        #div #mod #plus #equal #more #less #comma #at
                        #per #none) ].
    ^ binaryOpSyms
  )

  keywordSelectorSyms = (
    keywordSelectorSyms == nil ifTrue: [
      keywordSelectorSyms := #(#keyword #keywordSequence) ].
    ^ keywordSelectorSyms
  )

  newWith: aString for: aFilename in: universe = (
    ^ self new initializeWith: aString for: aFilename in: universe
  )
)
