ScaleConstraint = BinaryConstraint (
    "I relate two variables by the linear scaling relationship:
    `v2 = (v1 * scale) + offset`. Either v1 or v2 may be changed to maintain
    this relationship but the scale factor and offset are considered read-only.

    Instance variables:
        scale       scale factor input variable <Variable>
        offset      offset input variable <Variable>"
    | scale offset |
    
    "initialize-release"

    src: srcVar scale: scaleVar offset: offsetVar dst: dstVar strength: strengthSymbol = (
        "Initialize myself with the given variables and strength."

        self strength: strengthSymbol.
        self v1: srcVar.
        self v2: dstVar.
        scale := scaleVar.
        offset := offsetVar.
        self direction: nil.
        self addConstraint.
    )

    "add/remove"

    addToGraph = (
        "Add myself to the constraint graph."

        v1 addConstraint: self.
        v2 addConstraint: self.
        scale addConstraint: self.
        offset addConstraint: self.
        self direction: nil.
    )

    removeFromGraph = (
        "Remove myself from the constraint graph."

        (self v1 == nil) ifFalse: [self v1 removeConstraint: self].
        (self v2 == nil) ifFalse: [self v2 removeConstraint: self].
        (scale == nil) ifFalse: [scale removeConstraint: self].
        (offset == nil) ifFalse: [offset removeConstraint: self].
        self direction: nil.
    )

    "planning"

    execute = (
        "Enforce this constraint. Assume that it is satisfied."

        (self direction == #forward)
            ifTrue: [self v2 value: (self v1 value * scale value) + offset value]
            ifFalse: [self v1 value: (self v2 value - offset value) // scale value].
    )

    inputsDo: aBlock = (
        "Evaluate the given block on my current input variable."

        (self direction == #forward)
            ifTrue: [aBlock value: self v1.
                     aBlock value: scale.
                     aBlock value: offset]
            ifFalse: [aBlock value: self v2.
                      aBlock value: scale.
                      aBlock value: offset].
    )

    recalculate = (
        "Calculate the walkabout strength, the stay flag, and, if it is 'stay',
         the value for the current output of this constraint. Assume this
         constraint is satisfied."

        | in out |
        (self direction == #forward)
            ifTrue:  [in  := self v1. out := self v2]
            ifFalse: [out := self v1. in  := self v2].
        out walkStrength: (self strength weakest: in walkStrength).
        out stay: ((in stay) and: [(scale stay) and: [offset stay]]).
        (out stay) ifTrue: [self execute].      "stay optimization"
    )
    
    ----

    "instance creation"

    var: src var: scale var: offset var: dst strength: strengthSymbol = (
        "Install a scale constraint with the given strength on the given
         variables."

        ^(self new) src: src scale: scale offset: offset dst: dst strength: strengthSymbol
    )
)